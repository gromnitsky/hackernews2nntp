// Generated by CoffeeScript 1.8.0
(function() {
  var Crawler, Q, Stat, events, fs, meta, path, request, util;

  util = require('util');

  events = require('events');

  fs = require('fs');

  path = require('path');

  request = require('request');

  Q = require('q');

  meta = require('../package.json');

  Stat = (function() {
    function Stat() {
      this.reset();
    }

    Stat.prototype.reset = function() {
      this.downloaded = {
        files: 0,
        bytes: 0
      };
      this.failed = 0;
      this.invalid = 0;
      this.stale = 0;
      this.job = {
        cur: 0,
        planned: 0
      };
      return this.history = {};
    };

    Stat.prototype.total = function() {
      return this.downloaded.files + this.failed + this.invalid;
    };

    Stat.prototype.finished = function() {
      return (this.total() === this.job.planned) && (this.job.planned !== 0);
    };

    Stat.prototype.toString = function() {
      return "downloaded files/bytes: " + this.downloaded.files + "/" + this.downloaded.bytes + ", failed: " + this.failed + ", invalid: " + this.invalid + ", stale: " + this.stale + ", total: " + (this.total());
    };

    Stat.prototype.history_add = function(id, body) {
      if (body == null) {
        body = "";
      }
      this.downloaded.files += 1;
      this.downloaded.bytes += Buffer.byteLength(body);
      return this.history[id] = true;
    };

    return Stat;

  })();

  Crawler = (function() {
    function Crawler(url_pattern, job_planned) {
      this.url_pattern = url_pattern;
      this.stat = new Stat();
      this.stat.job.planned = job_planned;
      this.log = console.error;
      this.headers = {
        'User-Agent': [meta.name, meta.version].join('/')
      };
      this.event = new events.EventEmitter();
      this.look4kids = true;
    }

    Crawler.prototype.url = function(id) {
      return util.format(this.url_pattern, id);
    };

    Crawler.prototype.prefix = function(id, level) {
      return "jc=" + this.stat.job.cur + "/l=" + level + "/jp=" + this.stat.job.planned + " " + (this.url(id));
    };

    Crawler.prototype.get_item = function(id, level, expected_type) {
      var deferred, prefix;
      if (level == null) {
        level = 0;
      }
      if (expected_type == null) {
        expected_type = null;
      }
      this.stat.job.cur += 1;
      prefix = this.prefix(id, level);
      deferred = Q.defer();
      if (!id) {
        deferred.reject(new Error("no id, cannot do HTTP GET"));
        return deferred.promise;
      }
      request.get({
        url: this.url(id),
        headers: this.headers
      }, (function(_this) {
        return function(err, res, body) {
          var json, kid, _i, _len, _ref, _ref1, _ref2;
          if (err) {
            _this.stat.failed += 1;
            _this.log("" + prefix + ": Error: " + err.message);
            deferred.reject(new Error("" + id + ": " + err.message));
            return;
          }
          if (res.statusCode === 200) {
            _this.log("" + prefix + ": HTTP 200");
            if (!(json = _this.parse_body(body, deferred))) {
              return;
            }
            _this.stat.history_add(id, body);
            if (json.type === 'poll') {
              _this.log("" + prefix + ": collecting " + json.parts.length + " pollopts");
              _this.get_fullpoll(id, json.parts, body, deferred);
            } else {
              if (!((_ref = json.type) != null ? _ref.match(/^poll/) : void 0)) {
                _this.event.emit('body', body);
              }
              deferred.resolve(body);
            }
            if (_this.look4kids & ((_ref1 = json.kids) != null ? _ref1.length : void 0) > 0) {
              _this.log("" + prefix + ": " + json.kids.length + " kid(s)!");
              _this.stat.job.planned += json.kids.length;
              _ref2 = json.kids;
              for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                kid = _ref2[_i];
                _this.get_item(kid, level + 1, expected_type);
              }
            }
          } else {
            _this.stat.failed += 1;
            _this.log("" + prefix + ": HTTP " + res.statusCode);
            deferred.reject(new Error("" + id + ": HTTP " + res.statusCode));
          }
          if (_this.stat.finished()) {
            return _this.event.emit('finish', _this.stat);
          }
        };
      })(this)).on('request', (function(_this) {
        return function(req) {
          if (_this.stat.history[id] === true && expected_type !== 'pollopt') {
            _this.stat.stale += 1;
            deferred.reject(new Error("" + id + ": saw it already"));
            return deferred.promise;
          }
          return _this.log("" + prefix + ": HTTP GET");
        };
      })(this));
      return deferred.promise;
    };

    Crawler.prototype.parse_body = function(body, promise) {
      var e;
      try {
        return JSON.parse(body);
      } catch (_error) {
        e = _error;
        this.stat.failed += 1;
        promise.reject(new Error('invalid json'));
      }
      return null;
    };

    Crawler.prototype.get_fullpoll = function(poll_id, parts, poll_body, promise) {
      return this.collect_pollopts(poll_id, parts).then((function(_this) {
        return function(poll) {
          var body;
          body = ([poll_body].concat(poll)).join("\n");
          _this.event.emit('body', body);
          return promise.resolve(body);
        };
      })(this))["catch"]((function(_this) {
        return function(err) {
          _this.stat.failed += 1;
          _this.stat.downloaded.files -= 1;
          return promise.reject(err);
        };
      })(this)).done();
    };

    Crawler.prototype.collect_pollopts = function(poll_id, parts) {
      var deferred, idx, part, pollparts, pro, promises, _i, _len;
      deferred = Q.defer();
      if (parts.length === 0) {
        deferred.reject(new Error("" + poll_id + ": invalid poll w/o parts"));
        return deferred.promise;
      }
      this.stat.job.planned += parts.length;
      pollparts = [];
      promises = [];
      for (idx = _i = 0, _len = parts.length; _i < _len; idx = ++_i) {
        part = parts[idx];
        pro = this.get_item(part, 1, 'pollopt');
        promises.push(pro);
        pro.then(function(body) {
          return pollparts.push(body);
        })["catch"](function(err) {
          return deferred.reject(new Error("" + poll_id + ": poll is missing pollopt: " + err.message));
        }).done();
      }
      Q.all(promises).then(function() {
        return deferred.resolve(pollparts);
      });
      return deferred.promise;
    };

    return Crawler;

  })();

  module.exports = Crawler;

}).call(this);
